# TODO Items {#todos}

This section will walk the developer through each of the QuickStart `TODO` items. As each `TODO` is completed, it is recommended to remove it from the code.

Throughout this chapter, an example Plugin Developer who is part of the "Orchid Organization" and developing a Launcher Plugin for the "Mars" job scheduling system will be used. The theoretical Mars job scheduling provides a C/C++ interface, which will be referred to as the `mars_api`. It provides a set of free functions which allow the caller to get details from the Mars job scheduling system. `mars_api` calls may throw `mars_exceptions` which need to be handled.

## TODO #1: Change Namespaces {#todo-1}
 
TODO Location        Impact
-------------------  -----------------
QuickStartMain.cpp   All source files

The classes in the QuickStart RStudio Launcher Plugin are all in the `rstudio::launcher_plugins::quickstart` namespace. As desired, these namespaces may be changed. 

### Example {#todo-1-ex}

The Plugin Developer may change the following namespace definitions

```{c, echo=TRUE, eval=FALSE}
namespace rstudio {
namespace launcher_plugins {
namespace quickstart {
  ...
} // namespace quickstart
} // namespace launcher_plugins
} // namespace rstudio
```

to
```{c, echo=TRUE, eval=FALSE}
namespace orchid {
namespace mars {
  ...
} // namespace mars
} // namespace orchid
```


## TODO #2: Rename Classes {#todo-2}
 
TODO Location        Impact
-------------------  -----------------
QuickStartMain.cpp   All source files

### Example {#todo-2-ex}

The developer may now wish to rename all the classes from `QuickStart*` to `Mars*`. For example, `QuickStartMain` would become `MarsMain`.

In addition, the developer may also wish to modify the include guards to match their new namespace and class names. For example,

```{c, echo=TRUE, eval=FALSE}
#ifndef QUICKSTART_QUICK_START_PLUGIN_API
#define QUICKSTART_QUICK_START_PLUGIN_API
```

might become

```{c, echo=TRUE, eval=FALSE}
#ifndef ORCHID_MARS_PLUGIN_API
#define ORCHID_MARS_PLUGIN_API
```

The naming schemes described here are only recommendations. The exact naming scheme is completely at the discretion of the developer.


## TODO #3: Change the Plugin Name {#todo-3}
 
TODO Location        Impact
-------------------  -------------------
QuickStartMain.cpp   QuickStartMain.cpp


The plugin name is used to generate the program ID, which will be used for logging, and the configuration file name. By default, the program ID will be `"rstudio-" + getPluginName() + "-launcher"`. The configuration file name will be `"launcher." + getPluginName() + ".conf"` and must be located in `/etc/rstudio`.

### Example {#todo-3-ex}

The developer might now change

```{c, eval=FALSE}
std::string getPluginName() const override
{
  // TODO #3: Change the Plugin Name
  return "quickstart";
}
```

to 

```{c, eval=FALSE}
std::string getPluginName() const override
{
  return "mars";
}
```

## TODO #4: Optionally Change the Program ID {#todo-4}
 
TODO Location        Impact
-------------------  -------------------
QuickStartMain.cpp   QuickStartMain.cpp


The program ID will be used to uniquely identify logs from the plugin that are sent to the system log. By default, the value will be `"rstudio-" + getPluginName() + "-launcher"`, however it is possible to override `AbstractMain::getProgramID()` to set a custom program ID.

### Example {#todo-4-ex}

The developer might add 

```{c, eval=FALSE}
std::string getProgramId() const override
{
  return "orchid-" + getProgramName() + "-launcher";
}
```

to `MarsMain.cpp`.

## TODO #5: Add Options  {#todo-5}
 
TODO Location           Impact
----------------------  ---------------------------------------------
QuickStartOptions.cpp   QuickStartOptions.cpp, QuickStartOptions.hpp

The QuickStartOptions class demonstrates how to add job scheduling specific options to the Plugin. It may not be immediately obvious what options will be required for the Plugin, but when it does become clear that an option is needed it can be added here.

### Example {#todo-5-ex}

Suppose that the Mars job scheduling system can be controlled using an HTTP API, and it can be set up at a custom URL and port. The Orchid developer might then add a required option for the URL, an optional option for whether SSL should be used, and an optional option for the port. Additionally, the Mars Launcher Plugin will need to be able to make requests (such as listing all of the jobs in the system) as an administrator user. In that case, the developer might modify QuickStartOptions.hpp and QuickStartOptions.cpp in the following way:


**QuickStartOptions.hpp**

```{Rcpp, eval=FALSE}
class QuickStartOptions : public Noncopyable
{
public:
// ...
  
  bool getSampleOption() const;
   
// ...
   
private:
// ...
  
  bool m_sampleOption;
}
```

**QuickStartOptions.cpp**

```{Rcpp, eval=FALSE}
bool QuickStartOptions::getSampleOption() const 
{
  return m_sampleOption;
}

void QuickStartOptions::initialize()
{
   // TODO #5: Add options, as necessary.
   using namespace rstudio::launcher_plugins::options;
   Options& options = Options::getInstance();
   options.registerOptions()
      ("sample-option",
       Value<bool>(m_sampleOption).setDefaultValue(true),
       "sample option to demonstrate how to register options");
}

```

**MarsOptions.hpp**

```{Rcpp, eval=FALSE}
namespace orchid {
namespace mars {
namespace options {

class MarsOptions : public Noncopyable
{
public:
// ...
  
  const std::string& getMarsServiceUser() const;
  
  const std::string& getHost() const;
  
  unsigned int getPort() const;
  
  bool getUseSsl() const;
   
// ...
   
private:
// ...
  
  std:string m_marsServiceUser;
  
  std::string m_host;
  
  unsigned int m_port;
  
  bool m_useSsl;
}

} // namespace options
} // namespace mars
} // namespace orchid
```

**MarsOptions.cpp**

```{Rcpp, eval=FALSE}
#include "options/MarsOptions.hpp"

#include <options/Options.hpp>

namespace orchid {
namespace mars {
namespace options {

const std::string& MarsOptions::getHost() const 
{
  return m_host;
}

unsigned int MarsOptions::getPort() const 
{
  if (m_port != 0)
    return m_port;
  
  if (m_useSsl)
    return 443;
  
  return 80;
}

bool MarsOptions::getUseSsl() const 
{
  return m_useSsl;
}

void MarsOptions::initialize()
{
  // TODO #5: Add options, as necessary.
  using namespace rstudio::launcher_plugins::options;
  Options& options = Options::getInstance();
  options.registerOptions()
    ("mars-service-user",
     Value<std::string>(m_host).setDefaultValue("mars"),
     "a user which can make service requests to the Mars server")
    ("host",
     Value<std::string>(m_host),
     "the IP address or hostname of the Mars server")
    ("port",
     Value<unsigned int>(m_port).setDefaultValue(0),
     "the port to use for connecting to the Mars server")
    ("use-ssl",
     Value<bool>(m_useSsl).setDefaultValue(false),
     "whether to use HTTPS (true) or HTTP (false, default) when connecting to the Mars server");
}

} // namespace options
} // namespace mars
} // namespace orchid
```

## TODO #6: Initilaize Communication {#todo-6}
 
TODO Location             Impact
------------------------  ------------------------
QuickStartJobSource.cpp   QuickStartJobSource.cpp


The next step is to initialize communication with the job scheduling system. This might involve opening a TCP connection to the job scheduling system which will remain open for the duration of the Plugin's lifetime, or it might involve testing that it is possible to connect to the job scheduling system. In the case of the sample Local Plugin, provided with this SDK, no communication test is necessary since jobs will be run on the local machine.

Any other tasks which need to be completed before the Plugin is ready to launch jobs must be completed here. For example, in the RStudio SLURM Launcher Plugin it was also necessary to check which timezone the SLURM cluster is using, since job timestamps need to be compared later on. If the Plugin implementation will be tied to a specific version, or set of versions, of the job scheduling system, that should be validated here as well.

### Example {#todo-6-ex}

The Plugin Developer may now change

```{Rcpp, eval=FALSE}
#include <QuickStartJobSource.hpp>

#include <Error.hpp>

namespace rstudio {
namespace launcher_plugins {
namespace quickstart {

Error QuickStartJobSource::initialize()
{
   // TODO #6: Initialize communication with the job scheduling system. If communication fails, return an error.
   return Success();
}

} // namespace quickstart
} // namespace launcher_plugins
} // namespace rstudio
```

in `QuickStartJobSource.cpp` to


```{Rcpp,eval=FALSE}
#include "MarsJobSource.hpp"

#include <Error.hpp>
#include "options/MarsOptions.hpp"

namespace orchid {
namespace mars {

Error MarsJobSource::initialize()
{
  const options::MarsOptions& opts = options::MarsOptions::getInstance();
  
  try
  {
    mars_api::init(opts.host(), opts.port(), opts.useSsl());
  }
  catch (const mars_expcetion& e)
  {
    return Error("MarsApiError", e.code(), e.what(), ERROR_LOCATION);
  }
  
  return Success();
}

} // namespace mars
} // namespace orchid
```

## TODO #7: Define Cluster Configuration {#todo-7}
 
TODO Location             Impact
------------------------  ------------------------
QuickStartJobSource.cpp   QuickStartJobSource.cpp


RStudio applications which make use of the Launcher can determine the configuration and capabilities of each job scheduling system by submitting a Cluster Info request to the Launcher. Each Plugin is responsible for returning a complete and correct list of the configuration and capabilities of the job scheduling system with which it integrates. For more information about the Cluster Info request, see the RStudio Launcher Plugin SDK Developer Guide.

Some aspects of the configuration and capabilities may be independent of the end user or the Launcher, and others may differ by user. If any configuration or capability values should differ based on the end user, it is likely that these rules should be configurable by the system admin. For the convenience of the Plugin Developer, an `AbstractUserProfiles` class has been provided to facilitate the implementation of User Profiles. For more details about implementing this feature, please refer to the 'User Profiles' section of the 'Advanced Features' chapter of the RStudio Launcher Plugin SDK Developer Guide.

This section will describe the questions which need to be answered to correctly define the configuration and capabilities of a job scheduling system, and what value(s) of the `JobSourceConfiguration` structure should be modified in the overridden implementation of `IJobSource::getConfigurations`.

* Does the job scheduling system support or require containers (such as Docker or Singularity containers)? If yes:
    + set `JobSourceConfiguration::ContainerConfig::SupportsContainers` to `true`. Note that if `JobSourceConfiguration::ContainerConfig::SupportsContainers` is set to `false`, all other values of `JobSourceConfiguration::ContainerConfig` will be ignored.
    + decide how the list of available container images should be determined and add each container image name to `JobSourceConfiguration::ContainerConfig::ContainerImages`.
    + decide how the default container image should be determined, if any, and then set the value of `JobSourceConfiguration::ContainerConfig::DefaultImage`.
    * decide whether unknown images should be allowed and set `JobSourceConfiguration::ContainerConfig""AllowUnknownImages` to `true` or `false` as desired.
    > Info: The RStudio Kubernetes Launcher Plugin allows system administrators to control the list of available container images, the default image, and whether unknown images should be allowed on a per-user or per-group basis through the User Profiles feature. For an example of what that configuration looks like, see the sample `launcher.kubernetes.profiles.conf` file in the [Job Launcher Plugin Configuration section of the RStudio Job Launcher Administrator's Guide](https://docs.rstudio.com/job-launcher/index.html#job-launcher-plugin-configuration).
    
    &nbsp;

* Does the job scheduling system support job queues? A job queue is a subset of machines within the job scheduling system. When a job is submitted to the job scheduling system, a specific queue may be requested and the job should be run on one or more of the machines in the requested queue. In some job scheduling systems, this may also be known as a "partition". If yes:
    + pull down the list of queues from the job scheduling system, or otherwise determine the list available queues, and add each queue to `JobSourceConfiguration::Queues`.
    
* Does the job scheduling system support setting resource limits on a job?
    + determine the type of resource limits that are supported by the job scheduling system. The SDK allows the following resource types: Cpu Count, Cpu Time, Memory, and Memory Swap. For each supported type add a `ResourceLimit` object of that type to `JobSourceConfiguration::ResourceLimits`, optionally setting the maximum and default values of that resource limit type.

    &nbsp;

    > Info: The existing RStudio Launcher Plugins allow system administrators to configure the maximum and default values for each resource type on a per-user or per-group basis through the User Profiles feature. From an exampleof what that looks like, see a sample `launcher.<plugin name>.profiles.conf` [Job Launcher Plugin Configuration section of the RStudio Job Launcher Administrator's Guide](https://docs.rstudio.com/job-launcher/index.html#job-launcher-plugin-configuration).

* Does the job scheduling system support other placement constraints that are important to surface? It is not necessary to surface every placement constraint supported by the job scheduling system; however if any constraints are commonly used or otherwise important to the end user, they may be surfaced through this feature. Examples of such constraints may be other types of resource limits (e.g. disk space, GPU count, GPU time, etc.), or other types of constraints entirely (e.g. disk type, region of a cloud service, etc.). If yes:
    + for each placement constraint type, add one `PlacementConstraint` object to `JobSourceConfiguration::PlacementConstraints` for each possible value of that constraint.

> Important: Whether or not to use the `system::User` parameter provided to each of the capabilities methods is at the discretion of the Plugin Developer. If the Plugin Developer does not wish to support User Profiles and does not have another method to determine per-user or per-group rules, the `system::User` parameter may simply be ignored.

If there are any job configuration values which cannot be covered by one of the above categories, refer to the 'Custom Job Source Configuration' section of the 'Advanced Features' chapter of the RStudio Launcher Plugin SDK Developer's Guide.

### Example {#todo-7-ex}

Assume that the Mars scheduling system has the following capabilities:

* container support
* a way to list available container images that are available to a given user
* no default container image
* no way to specify unknown images
* a way to set a limit on the number of CPUs, the amount of Memory, and the number of GPUs, and a way to check the maximum possible values that can be requested
* job queues

The Plugin developer can report this support by changing

```{Rcpp, eval=FALSE}
Error QuickStartJobSource::getConfiguration(
  const system::User& in_user,
  api::JobSourceConfiguration& out_configuration) const
{
  // TODO #7: Define cluster configuration.
  return Success();
}
```

in `QuickStartJobSource.cpp` to

```{Rcpp, eval=FALSE}
Error MarsJobSource::getConfiguration(
  const system::User& in_user,
  api::JobSourceConfiguration& out_configuration) const
{
  api::ContainerConfiguration& containerConfig = out_configuration.ContainerConfig;
  containerConfig.SupportsContainers = true;
   
  int maxGpuCount = 0, maxCpuCount = 0, maxMemoryMB = 0;
  try
  {
    // Get the container images and the queues.
    containerConfig.ContainerImages = mars_api::get_images(in_user.getUsername());
    out_configuration.Queues  = mars_api::get_queues());
    
    // Get the maximum resource limit and placement constraint values.
    maxGpuCount = mars_api::get_total_gpus();
    maxCpuCount = mars_api::get_total_cpus();
    maxMemoryMB = mars_api::get_max_memory();
  }
  catch (const mars_exception& e)
  {
    return Error("MarsApiError", e.code(), e.what(), ERROR_LOCATION);
  }
  
  // Populate placement constraints with one constraint value for gpu_count for each integer
  // less than or equal to the maximum gpu_count value.
  for (int i = 0; i <= maxCpuCount; ++i)
    out_configuration.PlacementConstraints.emplace_back("gpu_count", std::toString(i));
  
  // Populate the resource limits.
  out_configuration.ResourceLimits.emplace_back(
    api::ResourceLimit::Type::CPU_COUNT,
    std::toString(maxCpuCount));
  out_configuration.ResourceLimits.emplace_back(
    api::ResourceLimit::Type::MEMORY,
    std::toString((double)maxMemoryMB));
  
  return Success();
}
```

in `MarsJobSource.cpp`.
  
  
## TODO #8: Pull all jobs {#todo-8}

When the Launcher starts the Plugin, it will send a Bootstrap request to ensure that the Plugin is initialized. During this request, the Plugin SDK will populate the `JobRepository` with any pre-existing Launcher jobs by calling `IJobSource::getJobs`. The Plugin developer needs to override `IJobSource::getJobs` to synchronously pull down the list jobs that are already in the Job Scheduling System.

Any jobs which were not launched by the Plugin should not be included in the output. To distinguish between jobs that were launched by the Plugin and jobs that were launched either manually or by another tool, it may be useful to preface the name of the job with a unique tag (e.g. `'[RStudio Launcher] <job name>`). Alternately, if the Job Scheduling System supports setting custom fields on the job, a custom field may be used to indicate that the job was launched through the Plugin. Note that if a unique prefix is added to Launcher jobs by the Plugin, it should be removed from the job name before being returned to the Launcher.

Each job detail must be converted from the format in the Job Scheduling System to the format understood by the Launcher. 
For example, if dates are represented as a string in the Job Scheduling System, they must be parsed as a `system::DateTime` before the associated `Job` object can be updated. For more information about parsing dates from strings, see the 'Date-Time Support' section of the 'Advanced Features' chapter of the RStudio Launcher Plugin SDK Developer's Guide.

### Job Fields {#todo-8-fields}

The `Job` object has a field for each detail that the Launcher requires. This document will discuss some of the fields which require special consideration. Because jobs may remain in the system between Plugin restarts, the Plugin must be able to populate each field of the `Job` object exactly as it would have been when it was submitted to the Plugin based on the record of the job in the Job Scheduling System. If any fields cannot be retrieved from the Job Scheduling System, it will most likely be easier to ignore them during this TODO and design a solution during [TODO #10](#todo-10). Then it  For more information about each field, see the RStudio Launcher Plugin SDK API Reference.

#### Command vs. Exe vs. Container {#todo-8-command-exe}

Depending on whether a Plugin supports containers, there are two or three possible ways a job may be submitted to the Plugin. Without container support, a job may be submitted wither either the `Job::Command` or the `Job::Exe` field set. The difference is that a job submitted with the `Job::Command` field populated should be executed as a shell command (e.g. `/bin/sh -c <Command>`), and a job submitted with the `Job::Exe` field populated should be executed directly. With container support, the job may be submitted with the `Command` and `Container` fields set, with the `Exe` and `Container` fields set, or just with the `Container` field set. In that case, the `Container` field describes the `Container` that should run either the shell command or the executable, or if no command or executable was set, the `Container` itself is the job to be run. Job submission is discussed in more detail in [TODO #10](#todo-10).

The Plugin must be able to determine from the Job Scheduling System's record of the job which of the `Job::Command`, `Job::Exe`, and `Job::Container` fields should be populated, and must be able to repopulate those fields exactly as they were when they were submitted to the Plugin.

#### Job Status {#todo-8-job-status}

Another special consideration is how to convert from the Job Scheduling System's job status to the RStudio Launcher Plugin SDK job status. To help with the conversion, below is a table which describes all of the `Job::State` enumeration values and their meaning with respect to the state of the job.

| `Job::State` Value | Meaning
| ------------------ | ---------------------------------------------------------------------------
| `CANCELED`         | The job was canceled by the user before it transitioned to the `RUNNING` state.
| `FAILED`           | The job could not be launched by the Job Scheduling System. This does not include a job that runs and exits with a non-zero exit code.
| `FINISHED`         | The job was launched by the Job Scheduling System and has exited. This includes jobs which exit with a non-zero exit code.
| `KILLED`           | The job was forcibly stopped, using `SIGKILL`.
| `PENDING`          | The job has been submitted to the Job Scheduling System but has not started running yet.
| `RUNNING`          | The job is currently running.
| `SUSPENDED`        | The job has been paused by the user, and may be resumed later.
| `UNKNOWN`          | This is not a job status - it represents the default value of the job state, before it has been submitted to the Plugin. Jobs populated by the Plugin should not have this status.

### Example {#todo-8-ex}

Assume the following:

* the Mars Job Scheduling System API has a `list_jobs` function which takes a username. It retrieves the jobs the specified user has permission to see.
* the Orchid organization's developer has added a `marsJobToJob` helper function which converts a `mars_api::job` structure to an `rstudio::launcher_plugins::api::Job` structure.

In that case, the Plugin developer might change

```{Rcpp, eval=FALSE}

Error QuickStartJobSource::getJobs(api::JobList &out_jobs) const
{
  // TODO #8: Pull all RStudio jobs from the job scheduling system synchronously.
  return Success();
}
```

in `QuickStartJobSource.cpp` to 

```{Rcpp, eval=FALSE}

Error MarsJobSource::getJobs(api::JobList &out_jobs) const
{
  const options::MarsOptions& opts = options::MarsOptions::getInstance();
  std::vector<mars_api::job> marsJobs;
  try
  {
    marsJobs = mars_api::list_jobs(opts.getMarsServiceUser());
  }
  catch (const mars_expcetion& e)
  {
    return Error("MarsApiError", e.code(), e.what(), ERROR_LOCATION);
  }
  
  for (const mars_api::job& job: marsJobs)
    out_jobs.push_back(marsJobTojob(job));
  
  return Success();
}
```

in `MarsJobSource.cpp`.
